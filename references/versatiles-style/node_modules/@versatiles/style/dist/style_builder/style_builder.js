import Color from 'color';
import { getShortbreadTemplate, getShortbreadLayers } from '../shortbread/index.js';
import { decorate } from './decorator.js';
import { CachedRecolor, getDefaultRecolorFlags } from './recolor.js';
import { deepClone, resolveUrl } from '../lib/utils.js';
// StyleBuilder class definition
export default class StyleBuilder {
    #sourceName = 'versatiles-shortbread';
    build(options) {
        options ??= {};
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        const baseUrl = options.baseUrl ?? globalThis?.document?.location?.href ?? 'https://tiles.versatiles.org';
        const glyphs = options.glyphs ?? '/assets/fonts/{fontstack}/{range}.pbf';
        const sprite = options.sprite ?? '/assets/sprites/sprites';
        const tiles = options.tiles ?? ['/tiles/osm/{z}/{x}/{y}'];
        const hideLabels = options.hideLabels ?? false;
        const { languageSuffix } = options;
        const recolorOptions = options.recolor ?? getDefaultRecolorFlags();
        const colors = this.getColors(this.defaultColors);
        if (options.colors) {
            for (const key in options.colors)
                colors[key] = Color(options.colors[key]);
        }
        const fonts = deepClone(this.defaultFonts);
        if (options.fonts) {
            for (const key in options.fonts) {
                const fontName = options.fonts[key];
                if (fontName != null)
                    fonts[key] = fontName;
            }
        }
        // get empty shortbread style
        const style = getShortbreadTemplate();
        const styleRuleOptions = {
            colors,
            fonts,
            languageSuffix,
        };
        // get layer style rules from child class
        const layerStyleRules = this.getStyleRules(styleRuleOptions);
        // get shortbread layers
        const layerDefinitions = getShortbreadLayers({ languageSuffix });
        let layers = layerDefinitions.map(layer => {
            switch (layer.type) {
                case 'background':
                    return layer;
                case 'fill':
                case 'line':
                case 'symbol':
                    return {
                        source: this.#sourceName,
                        ...layer,
                    };
            }
            throw Error('unknown layer type');
        });
        // apply layer rules
        layers = decorate(layers, layerStyleRules, new CachedRecolor(recolorOptions));
        // hide labels, if wanted
        if (hideLabels)
            layers = layers.filter(l => l.type !== 'symbol');
        style.layers = layers;
        style.name = 'versatiles-' + this.name.toLowerCase();
        style.glyphs = resolveUrl(baseUrl, glyphs);
        style.sprite = resolveUrl(baseUrl, sprite);
        const source = style.sources[this.#sourceName];
        if ('tiles' in source)
            source.tiles = tiles.map(url => resolveUrl(baseUrl, url));
        return style;
    }
    getColors(colors) {
        const entriesString = Object.entries(colors);
        const entriesColor = entriesString.map(([key, value]) => [key, Color(value)]);
        const result = Object.fromEntries(entriesColor);
        return result;
    }
    getDefaultOptions() {
        return {
            baseUrl: '',
            glyphs: '',
            sprite: '',
            tiles: [],
            hideLabels: false,
            languageSuffix: undefined,
            colors: deepClone(this.defaultColors),
            fonts: deepClone(this.defaultFonts),
            recolor: getDefaultRecolorFlags(),
        };
    }
    transformDefaultColors(callback) {
        const colors = this.getColors(this.defaultColors);
        for (const key in colors) {
            this.defaultColors[key] = callback(colors[key]).hexa();
        }
    }
}
